name: Merge Community PR After Checks

'on':
  workflow_run:
    workflows: ['PR Quality Check']
    types: [completed]
  pull_request_target:
    types: [labeled]

permissions:
  contents: write
  pull-requests: write
  actions: read

jobs:
  merge:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request_target' || github.event.workflow_run.conclusion == 'success'

    concurrency:
      group: community-merge-after-check-${{ github.event.pull_request.number || github.event.workflow_run.id || github.run_id }}
      cancel-in-progress: false

    steps:
      - name: Merge community PR
        if: github.event_name != 'pull_request_target' || github.event.pull_request.head.repo.full_name == github.repository
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AUTOMATION_PR_TOKEN }}
          script: |
            async function sleep(ms) {
              return new Promise(function(resolve) { setTimeout(resolve, ms); });
            }

            let prNumber = null;
            let expectedHeadSha = null;

            if (context.eventName === 'workflow_run') {
              const run = context.payload.workflow_run;
              const prs = run.pull_requests || [];

              if (!prs.length) {
                console.log('No pull request associated with this workflow_run');
                return;
              }

              prNumber = prs[0].number;
              expectedHeadSha = run.head_sha;
            } else {
              const pr = context.payload.pull_request;
              const label = context.payload.label;

              if (!label || label.name !== 'community-auto-merge') {
                console.log('Label event is not community-auto-merge; skipping');
                return;
              }

              prNumber = pr.number;
              expectedHeadSha = pr.head.sha;
            }

            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            if (!pr.head || pr.head.sha !== expectedHeadSha) {
              console.log(`PR #${prNumber} head SHA does not match expected head SHA; skipping`);
              return;
            }

            if (pr.state !== 'open') {
              console.log(`PR #${prNumber} is not open`);
              return;
            }

            if (pr.draft) {
              console.log(`PR #${prNumber} is a draft`);
              return;
            }

            if (pr.head && pr.head.ref && pr.head.ref.startsWith('automation/')) {
              console.log(`PR #${prNumber} is an automation PR; skipping`);
              return;
            }

            const labels = (pr.labels || []).map(function(l) { return l.name; });

            if (!labels.includes('community-auto-merge')) {
              console.log(`PR #${prNumber} is not marked for auto-merge`);
              return;
            }

            if (context.eventName === 'pull_request_target') {
              const { data: runs } = await github.rest.actions.listWorkflowRunsForWorkflow({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: 'pr-check.yml',
                head_sha: expectedHeadSha,
                per_page: 1
              });

              const latestRun = (runs.workflow_runs && runs.workflow_runs[0]) ? runs.workflow_runs[0] : null;
              if (!latestRun || latestRun.conclusion !== 'success') {
                console.log(`PR #${prNumber} does not have a successful PR Quality Check run for this SHA yet`);
                return;
              }
            }

            if (pr.mergeable === false) {
              console.log(`PR #${prNumber} is not mergeable`);
              return;
            }

            const MAX_RETRIES = 10;
            for (let i = 1; i <= MAX_RETRIES; i += 1) {
              try {
                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  merge_method: 'squash'
                });
                console.log(`Merged community PR #${prNumber}`);
                return;
              } catch (e) {
                console.log(`Merge attempt ${i} failed: ${e.message}`);
                if (e.status === 409) {
                  try {
                    await github.rest.pulls.updateBranch({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: prNumber
                    });
                    console.log(`Requested branch update for PR #${prNumber}`);
                  } catch (updateErr) {
                    console.log(`Could not update branch: ${updateErr.message}`);
                  }
                }
                if (i < MAX_RETRIES) {
                  await sleep(5000);
                }
              }
            }

            throw new Error(`Failed to merge community PR #${prNumber}`);
